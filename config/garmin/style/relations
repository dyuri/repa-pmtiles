# -------------------------------------------------------------------
# Hungarian Hiking Map - Relations Processing
# Based on process-hiking.lua relation_function() logic
# -------------------------------------------------------------------

# HIKING ROUTE RELATIONS
# These match the Lua: type=route & (route=hiking | route=foot)
# Extract trail color from OSMC symbol format: waycolor:background:foreground:text:textcolor

# Match specific OSMC color patterns and ACCUMULATE colors on ways
# When a way belongs to multiple colored routes, we need all colors (semicolon-separated)

type=route & route=hiking & osmc:symbol~'red:.*' {
    apply {
        set hiking_red=yes;
        add mkgmap:route_name='${name}';
        add mkgmap:route_ref='${ref}';
    }
}
type=route & route=hiking & osmc:symbol~'blue:.*' {
    apply {
        set hiking_blue=yes;
        add mkgmap:route_name='${name}';
        add mkgmap:route_ref='${ref}';
    }
}
type=route & route=hiking & osmc:symbol~'yellow:.*' {
    apply {
        set hiking_yellow=yes;
        add mkgmap:route_name='${name}';
        add mkgmap:route_ref='${ref}';
    }
}
type=route & route=hiking & osmc:symbol~'green:.*' {
    apply {
        set hiking_green=yes;
        add mkgmap:route_name='${name}';
        add mkgmap:route_ref='${ref}';
    }
}
type=route & route=hiking & osmc:symbol~'orange:.*' {
    apply {
        set hiking_orange=yes;
        add mkgmap:route_name='${name}';
        add mkgmap:route_ref='${ref}';
    }
}
type=route & route=hiking & osmc:symbol~'purple:.*' {
    apply {
        set hiking_purple=yes;
        add mkgmap:route_name='${name}';
        add mkgmap:route_ref='${ref}';
    }
}
type=route & route=hiking & osmc:symbol~'white:.*' {
    apply {
        set hiking_white=yes;
        add mkgmap:route_name='${name}';
        add mkgmap:route_ref='${ref}';
    }
}
type=route & route=hiking & osmc:symbol~'black:.*' {
    apply {
        set hiking_black=yes;
        add mkgmap:route_name='${name}';
        add mkgmap:route_ref='${ref}';
    }
}

# Fallback: Routes with explicit color tag but no OSMC symbol
type=route & route=hiking & color=red {
    apply { set hiking_red=yes; add mkgmap:route_name='${name}'; add mkgmap:route_ref='${ref}'; }
}
type=route & route=hiking & color=blue {
    apply { set hiking_blue=yes; add mkgmap:route_name='${name}'; add mkgmap:route_ref='${ref}'; }
}
type=route & route=hiking & color=yellow {
    apply { set hiking_yellow=yes; add mkgmap:route_name='${name}'; add mkgmap:route_ref='${ref}'; }
}
type=route & route=hiking & color=green {
    apply { set hiking_green=yes; add mkgmap:route_name='${name}'; add mkgmap:route_ref='${ref}'; }
}

# Generic hiking routes without specific color - mark as generic hiking trail
# This should match ALL hiking routes as a fallback
type=route & route=hiking {
    apply {
        set hiking=yes;
        set hiking_route=yes;
        add mkgmap:route_name='${name}';
        add mkgmap:route_ref='${ref}';
    }
}

# Foot routes (also hiking)
type=route & route=foot {
    apply {
        set hiking=yes;
        set route_name='${name}';
        set osmc:symbol='${osmc:symbol}';
        set route_ref='${ref}';
        set route_color='${color}';
        set route_network='${network}';
    }
}

# MTB routes (useful context)
type=route & route=mtb {
    apply {
        set mtb=yes;
        set route_name='${name}';
        set route_ref='${ref}';
        set route_color='${color}';
    }
}

# Bicycle routes
type=route & route=bicycle {
    apply {
        set bicycle=yes;
        set route_name='${name}';
        set route_ref='${ref}';
        set route_color='${color}';
    }
}

# Multipolygon relations for areas
type=multipolygon {
    # Apply tags from relation to the outline
    apply {
        # Copy relevant tags from relation to ways
        set natural='${natural}';
        set landuse='${landuse}';
        set leisure='${leisure}';
        set waterway='${waterway}';
        set name='${name}';
    }
}

# Administrative boundaries
type=boundary & boundary=administrative {
    # Apply admin_level to member ways
    apply {
        set boundary=administrative;
        set admin_level='${admin_level}';
        set name='${name}';
    }
}
